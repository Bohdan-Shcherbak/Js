// Разные подходы к решению задач

// Полный перебор.(brute force - грубая сила)*************
// Примером алгоритма полного перебора является линейный поиск значения в массиве.
// Полный перебор

// Разделяй и властвуй.(divide and conquer)***************
// Если задачу можно разделить на более мелкие части, то нужно ее разделить,
// и продолжать делить, пока это будет возможным.
// Потом решить задачу для каждой части и объединить полученные результаты
//  при необходимости.
// Так мы поступаем, когда ищем слово в словаре: открываем книгу
// на середине и смотрим, в какой ее части находится нужное слово.
// Определившись, мы можем отбросить половину задачи и продолжать работать с
//  оставшейся.

// Динамическое программирование.(dynamic programing)***********
// Суть динамического программирования такая же, как у
// "разделяй и властвуй": разделение большой задачи на подзадачи.
// Динамическое программирование в некотором смысле расширяет
//  "разделяй и властвуй" и применяется для более узкого набора проблем.
// Динамические алгоритмы могут многократно использовать результаты
// выполнения более мелких подзадач для решения более крупных, до тех пор,
//  пока не будет решена основная задача.

// Жадные алгоритмы.(greedy algorithms)**********
// Более сложный подход к решению проблем предполагает на каждом локальном этапе
// принятие решений, которые на данный момент являются оптимальными.
// Допускается, что конечное решение тоже будет оптимальным.
// Требуется выдать конкретную сумму минимально возможным количеством монет
//  разного достоинства (10 рублей, 5 рублей, 2 рубля, 1 рубль).
//  Сначала набираем максимально возможную сумму монетами самого высокого
//  достоинства (10 рублей). Потом переходим к пяти-рублевым и пытаемся
//  набрать ими остаток и так далее.

// Алгоритмы сортировки массивов************

// пузырьковую сортировку;***************
// Он берет два первых элемента массива, сравнивает их и расставляет по порядку.
//  Затем происходит смещение на один элемент вправо и сравниваются уже второй и
//   третий элементы. И так далее до конца массива.
let arr = [6, 5, 3, 1, 8, 7, 2, 4];
const comparator = (a, b) => a - b;
const swap = (arr, i, j) => [arr[i], arr[j]] = [arr[j], arr[i]]

function bubbleSort(arr) {
    for (let j = arr.length - 1; j > 0; j--) {
        for (let i = 0; i < j; i++) {
            if (comparator(arr[i], arr[i + 1]) > 0) {
                swap(arr, i, i + 1);
            }
        }
    }
}
// bubbleSort(arr);
// console.log(arr);

// Пузырьковая сортировка является устойчивой, а ее временная сложность составляет
//  O(N²) в худшем случае. Это означает, что для массива с n элементами нужно
//  совершить n2 операций: для каждого из элементов приходится сделать проход
//  по всем остальным элементам массива.

// сортировку выбором; **************
// Этот алгоритм похож на сортировку пузырьком: он на каждой итерации
//  отсортировывает один элемент, только собираются они не в конце массива, а в
// начале.
function selectionSort(arr) {
    for (let i = 0; i < arr.length - 1; i++) {
        let min = i;

        for (let j = i + 1; j < arr.length; j++) {
            if (comparator(arr[min], arr[j]) > 0) {
                min = j;
            }
        }

        if (min !== i) swap(arr, i, min);
    }
}
//   В отличие от пузырьковой, сортировка выбором неустойчива, 
//   но сложность у нее такая же – O(N²).

// сортировку вставками;****************
// Полагается, что начало массива уже отсортировано (изначально 1 элемент). 
// Алгоритм берет первый неотсортированный элемент (индекс 1) и последовательно 
// сравнивает его с отсортированными, находя нужное место. 
// После этого длина отсортированной части увеличивается (теперь уже два 
//     отсортированных элемента) и алгоритм переходит к следующему элементу 
//     (индекс 2).
// let arr = [6, 5, 3, 1, 8, 7, 2, 4];

function insertionSort(arr) {
    for (let i = 1; i < arr.length; i++) {
        let current = i;
        console.log(arr[current - 1]);//1 el 6; 6
        console.log(arr[current]);//2 el 5; 3
        while (arr[current - 1] !== undefined && comparator(arr[current], arr[current - 1]) < 0) {
            console.log('aga');
            swap(arr, current - 1, current);
            current--;
            console.log(current);

        }
    }
}
// insertionSort(arr)
// console.log(arr);
// Начинаем с первого элемента (нулевой считаем отсортированным).
// На каждой итерации сравниваем активный элемент с отсортированными и находим
// его место.
// Сложность сортировки вставками такая же, как у предыдущих алгоритмов – O(N²)
// в худшем случае (если массив отсортирован в обратном порядке). Алгоритм
//  является стабильным.

// сортировку слиянием;*********
// Сортировка слиянием – отличный пример применения стратегии
// "разделяй и властвуй".
// Алгоритм состоит из трех этапов:

// Исходный массив разделяется на две примерно равные части.
// Каждая часть сортируется отдельно.
// Обе отсортированные части объединяются в один массив.
function mergeSort(arr) {
    if (arr.length <= 1) return arr;

    // середина массива
    let middle = Math.floor(arr.length / 2);

    // два подмассива, которые будут сортироваться отдельно
    let left = arr.slice(0, middle);
    let right = arr.slice(middle);

    // слияние отсортированных подмассивов
    return mergeSortedArrays(mergeSort(left), mergeSort(right));
}

function mergeSortedArrays(arr1, arr2) {
    // Результат слияния
    let newArray = [];

    // текущие индексы сравниваемых элементов
    let index1 = 0;
    let index2 = 0;

    // сравнение активных элементов
    while (index1 < arr1.length && index2 < arr2.length) {
        let min = null;
        if (comparator(arr1[index1], arr2[index2]) <= 0) {
            min = arr1[index1]; // добавление минимального элемента в массив
            index1++; // сдвиг индекса активного элемента первого массива
        } else {
            min = arr2[index2];
            index2++;
        }

        newArray.push(min);

    }

    return [...newArray, ...arr1.slice(index1), ...arr2.slice(index2)];
}
// Сортировка слиянием является стабильной. Для нее требуется выполнить 
// n * log(n) операций. Это эффективнее, чем предыдущие алгоритмы.

// быструю сортировку.
// Алгоритм быстрой сортировки (сортировка Хоара), как ни странно, является одним из самых быстрых алгоритмов сортировки. Он немного похож и на пузырьковую сортировку, и на сортировку слиянием, так как тоже использует стратегию "разделяй и властвуй".

// Сначала в массиве выбирается опорный элемент (пивот). Выбрать его можно любым способом: например, взять первый, средний или случайный элемент. От способа выбора во многом зависит эффективность алгоритма.
// Затем все остальные элементы сравниваются с опорным и переставляются так, чтобы все элементы, которые меньше опорного оказались до него, а все, которые больше – после. Под больше и меньше здесь имеется в виду результат сортировки. На этом этапе в массиве сначала идут все элементы меньше опорного (для которых компаратор вернул отрицательное число), затем опорный, а затем все элементы больше опорного (компаратор вернул положительное число).
// И наконец для групп "меньше" и "больше" рекурсивно выполняется тот же самый алгоритм. Сам опорный элемент может быть включен в одну из групп.

function quickSort(arr, start, end) {
    if (start === undefined) start = 0;
    if (end === undefined) end = arr.length - 1;

    if (start >= end) return;

    // индекс опорного элемента
    let pivot = partition(arr, start, end);

    // рекурсивная сортировка подмассивов
    quickSort(arr, start, pivot - 1);
    quickSort(arr, pivot + 1, end);
}

function partition(arr, start, end) {
    // Берем в качестве опорного последний элемент подмассива
    let pivotValue = arr[end];

    // изначально считаем, что pivotValue минимальное значение
    // и должно находиться в начале массива
    let pivotIndex = start;

    // перебираем все элементы
    for (let i = start; i < end; i++) {
        // значения меньше опорного перемещаем перед ним
        if (comparator(arr[i], pivotValue) < 0) {
            swap(arr, i, pivotIndex);
            pivotIndex++;
        }
    }

    // ставим опорный элемент в нужное место
    swap(arr, pivotIndex, end);

    return pivotIndex;
}